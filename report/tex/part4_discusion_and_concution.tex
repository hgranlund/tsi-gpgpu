%!TEX root = ../main.tex

\section{Results and discussion} % (fold)
\label{sec:discussion}

\subsection{Interfacing with AML, developing a new editor and exploring new learning possibilities} % (fold)
\label{sub:interfacing_with_aml_developing_a_new_editor_and_exploring_new_learning_possibilities}
Section 3.1, contained an exploration of the possibilities for interfacing with AML from the system console and from another programming language. The console interface of AML was initially hard to work with, compared to the general programming languages Python and Common Lisp. The reason was mostly because the lack of documentation and the slightly laborious setup needed to launch the AML process in the console. However, improving the documentation, could make the difference negligible.

Then the possibility of controlling AML from another programming language was addressed. Several attempts at making a prototype REPL for AML in Python was made, however only two of the attempts where successful. Reading and writing to the AML process in different threads and using a pseudo-TTY. This was doe to AML utilizing block-buffered IO when being piped to another process. An argument was made, that this behavior is caused by the way the C standard IO library behaves.

This behavior made interfacing with AML from other programming languages unnecessary hard, and it was reviled that other programming languages avoids the problem, by giving the user the option of forcing line-buffered or unbuffered IO. Making such options part of AML would be a valuable feature.

In section 3.2, the RQ~\ref{rq:structure_aml} was studied by making a prototype integration of AML into the Sublime Text 2 editor. Using the strategy of configuring the editors existing Common Lisp support to work with AML, and then integrating the AML console into the editor, gave a working prototype. This prototype was further enhanced by some general configuration of Sublime, in the end, managing to duplicate the most important features of the AML XEmacs integration.

The main drawback of the prototype AML integration, was the problems related to controlling the AML process from Python, as described in section 3.1. If AML had the option of line-buffered or unbuffered IO, the entire integration could have been made using configuration of existing features and plug-ins of Sublime.

Even with the problems related to integrating the AML console, development of the Sublime integration was fairly straight forward. With the prototype integration only a minimum development and maintenance is needed, although both the quality and maintainability of the console integration is diminished to some degree.

%TODO: ref to "an argument was made"....below
The next question, RQ~\ref{rq:another_editor}, was not covered in as great depth as the first one, mainly due to the difficulty of integrating the AML console. An argument was made for the value of choice between editors, something that in a sense can be understood as a feature not readily available in XEmacs. A brief overview of notable features in Sublime was supplied. Although some of these features can be duplicated in XEmacs, XEmacs being a highly configurable editor, the focus was to investigate the features readily available in the editor. With this premise one can argue that a Sublime AML integration offers other features than XEmacs.

In the section 3.3, the learning challenges of AML where addressed, and the learning material of AML was discussed. Some shortcomings of the current learning material for AML was addressed, and the option of using learning material designed for Common Lisp was explored with good results. Finally the benefits of having an active on-line community during the learning process was also discussed.

This section leads to the question if the syntax of AML should be made more closely like, or even compatible with, the syntax of ANSI compliant Common Lisp. This would give the developer even more options to use previously written general software tools together with AML. Our learning experience with AML indicated that even with the existing, non ANSI compliant syntax, AML training can be improved by using the learning material and community support for Common Lisp. By making the syntax ANSI compliant, further gains from this strategy is expected, and this could give the developer the option of using existing software libraries and tools written for Common Lisp.

The trade-of of altering the syntax in such a way, is compatibility with previous versions of AML, as well as the more substantial resources needed to modify the AML modeling system. These would be needed to be throughly investigated in a more if such an undertaking was to be considered, but the possible gains of making this change makes us recommend that this should be studied in further work.
% subsection interfacing_with_aml_developing_a_new_editor_and_exploring_new_learning_possibilities (end)

\subsection{Building KBE models with Python and Open CASCADE} % (fold)
\label{sub:building_kbe_models_with_python_and_open_cascade}
In the introduction, another way of integrating GSD tools was introduced and the RQ~\ref{rq:intgenssofttools} was submitted.

The anatomy of a KBE system and different options for replacing the individual components was discussed, before settling with Python as the programming language, and Open CASCADE and FreeCAD for the geometric kernel and graphical viewer.

A test model of the missile system, described in the AML basic training manual, was developed. To aid with developing the model, ready made solutions for IDE, testing and debugging support was utilized. Compared to the troubles faced when developing the Sublime AML integration, this indicates that integrating general software tools is easier when the KBE-system is based on a widely used programming language.

More surprisingly, using this system to develop KBE models, was not as complicated as initially estimated, much due to the large amount of available open source tools and libraries. Notable drawbacks of using such a system was also identified in Section~\ref{sub:problems_with_switching_KBE_system}.
% subsection building_kbe_models_with_python_and_open_cascade (end)
% section discussion (end)


\section{Conclusion} % (fold)
\label{sec:conclusion}
The success of extending AML with parts from general software tools was in our cases largely dependent on the interfacing options to access AML from other programming languages. Documenting the console interface and allowing to force unbuffered or line buffered IO would have made the task of integrating AML into Sublime a trivial task, well within the grasp of a beginning KBE developer with some programming experience. It is our belief that this will enable developers to integrate AML into their favorite development tools, diversifying and expanding the AML system.

Documenting the console interface and allowing to force unbuffered or line buffered IO, seems to be possible to implement in AML without huge alterations to the existing framework.

Further modifications could be made to give AML a ANSI compatible syntax, giving AML developers even greater gain from using Common Lisp learning material as well as access to previously written libraries and tools for the more widely used Common Lisp language. If this where to be considered as an option, further investigation should be preformed, due to the possible complexities related to such modifications. Either way, resources used by Thecnosoft on developing learning material, might be better used on expanding the material covering KBE-specific parts of AML, and use learning material for Common Lisp to teach the basics of Lisp languages.

By experimenting with building KBE models with a widely used programming language, we instantly got access to testing, debugging and IDE/editor support. This we feel, demonstrates the advantages of having a KBE system that is compatible with general software tools. The obstacles of using such an approach is also apparent. Development time, quality, knowledge transfer from old systems, all makes this a more substantial undertaking than one might believe at first glance.

The ease of building KBE models with existing general software tools, should be seen as an incentive for Technosoft to push for better access to AML from other programming languages. Using a widely used general programming language at the core of a KBE model, instantly gives the developer access to a large amount of existing development tools, libraries and training material. Although development of KBE models with existing general software tools is not an viable alternative to AML today, this might change in the future. In such a scenario, changes would be needed to make AML an competitive option for the KBE developer.

To conclude this report, the authors would like to inform the reader that all code written as part of this project is freely available for use, re-use and sharing at \url{https://github.com/teodoran/TDT-4560}. An video-tutorial AMLRepl is available at \url{https://www.dropbox.com/s/5n2ksllro5kj72o/aml-repl-tutorial.mpg}.
% section conclusion (end)